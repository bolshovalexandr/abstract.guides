# Заметки по сложным вопросам в JS

## Intersection Observer API
- позволяет веб-приложениям асинхронно следить за изменением пересечения элемента с его родителем или областью видимости документа viewport
Основные сущности при работе с IOA:
- наблюдаемый элемент **target**
- пересекаемый элемент: зона просмотре (**viewport**) или родитель (**root**)
IOA обеспечивает вызов функции каждый раз при пересечении элементов

## Полезные приемы
- Math.max(...array) - и не надо никаких apply
- [...nodesCollection].forEach(fn) - не надо Array.from

## Загрузка по скроллу

Исх.:
- есть контейнер без скролла где-то на странице
- в тот момент, когда нижняя граница контейнера приблизится на 100px к нижней части экрана, нужно выполнить операцию загрузки комментариев

Реш.:
- смотрим у document.documentElement (корневой узел document, синоним тега html):
 = scrollTop даст высоту прокрученного содержимого (т.е. то, что осталось за границами экрана сверху)
 = clientHeight даст высоту содержимого в области видимости без учета рамок (border) и полосы горизонтальной прокрутки
 = scrollHeight - полная высота, включая прокрученную область

ТОГДА проверка достижения нижней части страницы сложится из
document.documentElement.scrollTop + document.documentElement.clientHeight >= document.documentElement.scrollHeight

## ООП
- super - это сокращение для вызова конструктора родительского класса для **создания нового контекста** (если унаследовать класс и использовать метод, использующий this, то получим ошибку this is not defined)



## Тротлинг и дебаунсинг


## Декораторы
*для понимания декораторов важно понимать управление свойствами объектов*
- дескриптор свойства - набор правил для свойства объекта (writable - доступность для записи, enumerable - перечислимость, configurable - возможность изменять дескриптор)
- метод объекта getOwnPropertyDescriptor возвращает дескриптор свойства, defineProperty позволяет свойство изменить (Object.defineProperties - определение нескольких свойств)
- создание объекта `const obj = {}` эквивалентно Object.create(Object.prototype, {_описание свойств_}), если же вместо прототипа указать null, то встроенные свойства объекта будут недоступны

```js
const myObj = {myPropOne: 'one'};
Object.getOwnPropertyDescriptor(
    myObj,
    'myPropOne'
);
Object.defineProperty(myObj, 'myPropOne', {
    writable: false
});
```


