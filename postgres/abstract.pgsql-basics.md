# Postgres - SQL-запросы

## Базовые заметки по РБД

### История и философия РБД
- первые БД были древовидными (с одним и многими родителями), для **связи между сущностями использовались ссылки**
- реляционные БД организованы в виде таблиц, а для **связи используется избыточность данных (внешние ключи) и уникальные ключи для записи в пределах таблицы**
- в РБД важно, чтобы **избыточность** была минимальной и использовалась лишь **для связи таблиц**, при этом каждая часть информации хранится и изменяется только в одном месте
- процесс **достижения вышеуказанного состояния** называется **нормализацией**

### терминология РБД
- ключ первичный - идентификатор строки таблицы, бывает **естественный** (напр., логин) и **суррогатный** (уникальный id);
- ключ внешний - дубликат первичного ключа из одной таблицы в другой таблице для связи;
- сущность (entity) - реальные данные (напр., данные пользователей, но не суррогатные ключи);
- столбец - отдельная часть данных, хранящихся в таблице (напр., фамилии);
- строка/запись - набор значений столбцов, полностью описывающий элемент сущности;
- таблица - набор строк, который может быть:
	- постоянным - данные в постоянной памяти;
	- непостоянным - обычно это результирующий набор, т.е. результат SQL-запроса к базе, хранящийся в ОЗУ



## Проектирование и архитектура

### Ограничения значений:
- функция ограничения целостности [CHECK](https://postgrespro.ru/docs/postgrespro/16/ddl-constraints),
- назначение столбца главным ключом (не NULL, уникальность), напр., `CONSTRAINT pk PRIMARY KEY(Id)`,
- указание для столбца внешнего ключа, напр., `"Id" int REFERENCES public."AnotherTable"("Id")`

## Соединения
*Реляционная БД не должна содержать избыточности, следовательно операции соединения таблиц применяются постоянно*

### WHERE и декартово произведение
- *Декартово или прямое произведение таблиц* - результат выборки всех значений из нескольких, пусть даже не  связанных друг с другом таблиц, при котором к каждой строке одной таблицы добавляются все строки другой
- при использовании WHERE условие применяется к декартову произведению

### JOIN и внешние/внутренние соединения

- JOIN - попарные соединения строк из двух таблиц
- понятия **правый и левый** - таблицы относительно ключевого слова JOIN
- внутренние соединения (INNER):
  - CROSS JOIN - декартово произведение
  - INNER JOIN - только те пары, для которых выполняются условия соединения
- внешние соединения (OUTER) - добавляют к внутреннему соединению соответственно строки из:
  - LEFT - строки из левого набора, которым не нашлось соответствия в правом наборе, при этом отсутствующие столбцы из правого набора получают NULL-значения (по факту LEFT - это все данные из таблицы СЛЕВА от JOIN),
  - RIGHT - прямо противоположно LEFT
  - FULL - объединение LEFT и RIGHT JOIN (но это не декартово произведение)


## Выборки

### SELECT
- после SELECT можно указывать любые выражения, а без указания FROM вернется одна строка (напр., можно использовать вычисления)


## Группировка и агрегатные функции

### Группировка
- при группировке в одной строке результата размещается значение, вычисленное на основании данных из нескольких строк таблицы;
- группировка по факту устраняет избыточность, например сгруппировав таблицу биржевых сделок, где есть множество повторяющихся тикеров, по столбцу ticker, мы получим список всех уникальных тикеров;
- на этом польза от группировки без использования агрегатных функций и заканчивается.

## Агрегатные функции
- агрегатные функции (count, avg, max и т.д.) расширяют возможности группировок, т.к. позволяют, напр., подсчитать количество и вывести поля, повторяющиеся определенное количество раз
```sql
select ticker, count(ticker) from exp_ticker_deals group by ticker having count(ticker) > 10;
```

