# CSS

## Заметки
- размер шрифта можно вычислять от vw `font-size: calc(0.5rem + 1vw);`
- шрифту можно задать с кл.словом относительный размер larger/smaller и начертание bolder/lighter
- text-align задается контейнеру, vertical-align - элементу
- line-height можно задавать в процентах или в виде множителя (рассчитывается от текущего размера шрифта)
- white-space позволяет сохранить пробелы и переносы как тег pre

## ключевое слово auto: отступы, позиционирование и т.д.
- родитель с фиксированной шириной, потомок с `width: 100%` выпадет из контейнера, с `width: auto` - впишется в контейнер. Похожая история с `margin-top: 100%` и т.п. - все эти 100% берутся от контейнера

## Каскадность, специфичность, наследование

- На специфичность влияет только тип селектора (идентификатор, класс, тег). Комбинаторы селекторов (+,~,^) на специфичность не влияют. Селекторы псевдокласса и типа атрибута специфичны в той же степени, что и селектор класса.
- Каскад - набор правил, по которым определяется результирующее (каскадное) значение свойства.

## Работа с относительными единицами
- 1 дюйм = 25,4 мм = 6 пик = 72 пункта = 96 пикселов (96 пикселов обычно составляют приблизительно 1 физический дюйм экрана)
- 1 em - размер текущего шрифта элемента. Значения, полученные браузером с использованием относительных единиц (em, проценты) называется *вычисленным* и в итоге выражается в абсолютных единицах
- если задать сам шрифт в em (напр., font-size: 1.2em), то за основу будет взято унаследованное значение, т.к. шрифт не может быть 1.2 сам от себя.
В примере сначала будет вычислен размер шрифта в 19,2px, а затем паддинг в 23,04px

```css
body {
    font-size: 16рх;
}
.slogan {
    font-size: 1.2em;
    padding: 1.2em;
}
```
Это порождает проблему сжатия/роста шрифтов при использовании em и вложенности, например при вложенных списках
- Единица rem (root em) решает проблему неоднозначности при вычислении em, т.к. за основу берется размер шрифта корневого элемента `html`.
- селектор псевдокласса `:root` позволяет получить html со специфичностью уровня класса, а не уровня тега, как при `html {}`
- **СОВЕТ:** используйте единицы rem для размера шрифта, пикселы — для границ и единицы em — для большинства других свойств.
- `vmin` - наименьшее из vw/vh, их удобно использовать, например, чтобы отрисовать квадрат, убирающийся во вьюпорт как на книжной, так и на альбомной ориентации
- с помощью vw можно задавать в т.ч. и размер шрифта **(font-size: calc(0.5rem + 1vw))**
- достаточно широкие возможности предоставляют пользовательские переменные - ими можно манипулировать из js

## Блочная модель
- слопываются только верхние и нижние маргины (тема пришла из типографики, дабы расстояния между параграфами не увеличивались в два раза)
- Предотвращение схлопывания полей:
	- спользование любого, кроме visible, значения свойства overflow у контейнера
	- обавление границы или паддинга
	- Поля не схлопываются внутри flex-контейнера
- селектор лоботомированной совы `* + * {}` - это компромиссное решение для манипуляциии со всем элементами, которые не являются первыми дочерними элементами родителя

## Адаптивный дизайн
- метатег viewport сообщает браузеру о наличии стилей для небольших экранов, атрибут content указывает, что интерпретировать стили надо от ширины экрана (а не эмулировать десктоп) и задействует свойство initial-scale для задания 100% масштаба при загрузке страницы (теоретически можно задать width, напр., в 320px)
```html
<meta name="viewport"
content="width=device-width, initial-scale=l">
```
- мадиазапросы можно нацеливать на
	- минимальные и максимальные ширины и высоты
	- ориентацию экрана (orientation: landscape, orientation: portrait)
	- плотность точек на пиксел (min-resolution: 2dppx, max-resolution: 2dppx)
	- носители (screen, print)
- Вы можете поместить медиазапрос в элемент link. Добавление на страницу <link rel="stylesheet" media="(min-width: 45em)" href="large-screen.css" /> обеспечит применение содержимого файла large-screen.css к странице только в том случае, если условие медиазапроса min-width окажется истинным. Обратите внимание на то, что таблица стилей будет загружаться вне зависимости от ширины области просмотра, поэтому данная тактика предназначена лишь для организации кода, а не для экономии трафика.
- Хорошая практика при адаптиве - добавлять изображениям max-width: 100%
- Паттерны адаптивной верстки http://bradfrost.github.io/this-is-responsive/patterns.html


## Flex
*изучение flex-верстки из-за обилия свойств напоминает попытку напиться из пожарного гидранта*

### Направления:
- вместо понятий "верх" и "низ" используется "поперечная ось" (cross axis), всегда перпендикулярная главной оси, вдоль которой расположены flex-элементы
- если главная ось горизонтальна - то поперечная смотрит вниз, если вертикальна - вправо => поперечная ось никогда не смотрит влево или вверх
- вдоль поперечной оси рассчитывается высота элементов и работает вертикальное выравнивание
- вертикальное выравнивание можно задать для каждого элемента (`align-self`), горизонтальное - только для контейнера
- flex-элементы расположены в несколько строк -> выравнивание строки управляет **align-content**
- **align-content** установлен в stretch -> отображением строку управляет align-items:
	- stretch - элементы растягиваются во всю высоту строки
	- другие значения - элементы ужимаются под свое содержимое и выравниваются в строках

### Заметки:
- **align-items** по умолчанию стоит в положении stretch
- **align-self** позволяет переопределить свойство **align-items** для конкретного элемента
- Значения свойства flex по умолчанию при сокращённой записи: flex-grow: 1, flex-shrink: 1 и flex-basis: 0%. Т.о., например, для трех колонок записи `flex: 6`, `flex: 3`, `flex: 1` гарантированно займут 60%, 30% и 10% ширины (**т.к. flex-basis: 0% по умолчанию**).
- grow/shrink могут быть не только 0 или 1, но и 2, 3 и т.д.
- При установленном flex-wrap: wrap
	- свойство **align-content** позволяет управлять промежутками между flex-строками вдоль поперечной оси
	- **flex-shrink** игнорируется, а элементы переносятся на следующую строку
- идеальное центрирование можно сделать с `margin: auto`

### Ключевые слова свойства flex
- **initial** Если я хочу, чтобы элемент немного сжимался, когда места недостаточно, но не тянулся шире чем ему надо: flex: 0 1 auto
- **auto** Если мой flex-элемент должен тянуться для заполнения всего доступного пространства, и немного сжиматься если места не хватает: flex: 1 1 auto
- **none** Если мой элемент не должен менять размеры совсем: flex: 0 0 auto (пр., `flex: none` повышает удобочитаемость)

### flex-basis, flex-grow и flex-shrink - алгоритм работы
#### полезные статьи:
- https://habr.com/ru/post/329820/
- https://medium.com/@stasonmars/разница-между-width-и-flex-basis-f34e658ce6a2
- https://medium.com/@stasonmars/как-работает-flex-grow-в-css-подробное-руководство-557d406be844
- https://medium.com/@stasonmars/как-работает-flex-shrink-в-css-подробное-руководство-c41e40767194

1. По приоритетам сначала идет flex-basis (ограниченный max|min-width), если он не указан - то width, если width не задан - ширина считается по размеру контента
 - **content → width → flex-basis (ограниченный max|min-width)**
 - если flex-basis: 100px, а min-width: 200px, то ширина элемента будет 200px
2. flex-basis - это **идеальный или предположительный, но НЕ ГАРАНТИРОВАННЫЙ размер** flex-элемента до того, как он попадет в контейнер
3. После размещения в контейнере в дело вступают flex-grow|shrink. По умолчанию (в т.ч если не определено сокращенное свойство flex) **flex-grow выставлен в 0, flex-shrink в 1**
4. flex-grow|shrink работают **только с тем свободным местом|его недостатком, которое осталось после вычисления flex-basis**, поэтому **только если мы установим flex-basis равным 0** и все наши элементы не будут иметь начальной ширины, пространство во flex-контейнере будет распределено соразмерно значениям flex-grow.
5. **flex-grow** при ненулевом flex-basis работает так:
 - вычисляется свободное место в контейнере
 - суммируются значения flex-grow у всех элементов
 - свободное место делится на сумму значений flex-grow у всех элементов и распределяется соответственно величине flex-grow каждого элемента
6. **flex-shrink** работает несколько сложнее (пример для контейнера **500px** и элеметнов **0 1 150px**, **0 2 200px** и **0 3 300px**)
 - сначала вычисляется недостаток свободного места (-150px)
 - далее вычисляется "общий вес" как сумма произведений ширин элементов на flex-shrink (1 * 150 + 2 * 200 + 3 * 300 = 1450)
 - величина сокращения для каждого элемента считается как недостаток_места * flex-shrink * ширину_элемента / общий_вес (напр., для 2го элемента это 150 * 2 * 200 / 1450 = -41.4)

**ВАЖНО:** по умолчанию min-width имеет значение auto, что **НЕ ПОЗВОЛЯЕТ элементу быть уже, чем его текстовое наполнение**
**СОВЕТ:** лучше использовать краткую запись flex, т.к. при ней **flex-grow|shrink|basis** будут установлены в **1,1 и 0%** соответственно. Если не задавать flex-элементу свойство flex, то значениями по умолчанию будут **0, 1 и auto** соответственно.


## Grids

### Общие вопросы
- грид-контейнер состоит из строк и столбцов, располагающихся между линий, нумерация линий идет с единицы
- грид-элемент задается начальными и конечными номерами солбцов и строк `grig-column/row-start/end`, при этом если задать `start/end` отрицательным, то отсчет пойдет справа/снизу

### Заметки
- В основе гридов - номера линий, разделяющих строки и столбцы. Номера могут быть отрицательными
- Грид-элементы могут наслаиваться друг на друга, при этом они начинают себя вести как будто абсолютно спозиционированные, при этом на них так же действует свойство z-index. Чем больше значение z-index, тем выше грид-элемент в «стопке».

- https://gridbyexample.com/
- CSS - сетка, это контейнер строки, в который вложены контейнеры для столбцов (именно в таком порядке)
- Концептуальная разница между flex- grid-версткой состоит в следующем:
    - flex-верстка по сути - это *одномерное выравнивание*, она отталкивается от контента, расположенного в одном направлении (строка/столбец). Контент может переноситься и выравниваться в пределах одной строки/столбца, но способа уровнять элементы в одной строке с элементами в другой при переносе нет **стр.193, рис 6.8**;
    - grid-верстка - *двумерное выравнивание*, при котором сначала строится сетка, а потом указывается, в какие ячейки будут помещены элементы
