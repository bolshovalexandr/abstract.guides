# Старые заметки из видеокурсов по .NET и ASP.NETCore

## ASP.Net Core - Структура проекта, окружение, создание
- шаблон empty создаёт hello world приложение со следующим минимально необходимым набором файлов:
	- `Connected Services`: подключенные сервисы из Azure
	- `Dependencies`: все добавленные в проект пакеты и библиотеки, иначе говоря зависимости
	- `Properties`: узел, который содержит некоторые настройки проекта. В частности, в файле launchSettings.json описаны настройки запуска проекта, например, адреса, по которым будет запускаться приложение.
	- `appsettings.json`: файл конфигурации проекта в формате json
	- `Program.cs`: главный файл приложения, с которого и начинается его выполнение. Код этого файла настривает и запускает веб-хост, в рамках которого разворачивается приложение
	- `Startup.cs`: файл, который определяет класс Startup и который содержит логику обработки входящих запросов


# Общие заметки, которые будут удалены после получения опыта
## Программы верхнего уровня:
	- могут быть только в одном экземпляре
	- операторы using должны располагаться в начале файла

## Файл .csproj
- LangVersion позволяет указать конкретную версию компилятора, либо псевдоним (latest, preview и т.п.)


# C#10 и .NET6 - Современная кросс-платформенная разработка (М. Прайс)

### .NET
- .NET Framework, .NET Core - устарели
- .NET(v.6 и далее) - основная платформа
- ASP.NET.Core работает на платформе .NET и объединяет компоненты ASP.NET MVC и ASP.NET Web-API, SignalR и gRPC для разработки веб-приложений и сервисов

### C#
- компиляция C# происходит в три этапа:
	- Roslyn (компилятор, используемый инструментом командной строки dotnet) конвертирует C#-код в IntermediateLanguage-код (IL) и сохраняет его в сборку (exe/dll-файл)
	- CoreCLR (Common Language Runtime) динамически (JIT, just-in-time) загружает IL-код из сборки
	- IL-код собирается под инструкции определенного CPU, т.о. один и тот же IL-код можно распространять на разные платформы

- сборка, как результат компиляции, это наименьшая единица развертывания .NET-проекта. Модификатор доступа internal ограничивает видимость именно сборкой

## Гл.1 - Привет, C#! Здравствуй, .NET!
- C#10 может неявно импортировать пространства имён (это можно увидеть в /obj/Debug/netX.X/Program.GlobalUsing.g.cs)

## Гл.2 - Говорим на языке C#

### Блоки:
- пространство имен содержит такие типы, как классы, для их группировки;
- класс содежит члены объекта, включая методы;
- метод содержит операторы, реализующие действия, которые может выполнять объект

### Пространства имен
- Когда мы импортируем пространство имен (напр., System, частью которого является Console), мы говорим, что все классы, которые не определены в нашем пространстве имен, надо искать в System
- Если определенные пространства имен нужны во всех модулях, то их можно импортировать в отдельном файле с помощью global using (это можно сделать в Program.cs, или создать отдельный файл. Хороший тон - GlobalUsings.cs или GlobalNamespaces.cs)
- Неявные глобальные импорты можно посмотреть в /obj/---/globalUsing.g.cs. Неявные импорты зависят от SDK
- Также управлять неявными импортами можно через .csproj-файл (напр. можно убрать System, и тогда отвалятся все Console.WriteLine)
```cs
	<ItemGroup>
		<Using Remove="System"/>
	</ItemGroup>
	<ImplicitUsings>enable</ImplicitUsings>
```

### Типы, классы, методы
- сам по себе C# не определяет типы, такие кл.слова как int или string являются псевдонимами для типов, опеределяемых платформой
- по факту в C# всё относится к какому-либо типу
- каждый тип может принадлежать к одной из категорий:
	- класс (напр. string)
	- структура (напр., int)
	- перечисление
	- интерфейс
	- делегат

#### Типы данных
- string, в отличие от остальных примитивов, ссылочный тип и может принимать значение null
- литерал в C# - фиксированное значение (число, символ, строка)
- символы и строки:
	- символ в одинарных кавычках, строка в двойных
	- дословно-литеральная строка (игнорирование escape-последовательностей) записывается как @"содержимое \t строки"
	- шаблонная строка $"текст {variable} текст"
- числа
	- double не обеспечиает надлежащую точность для чисел с плавающей точкой (см. проблему 0.1 + 0.2 != 0.3), надо использовать decimal
	- при этом присваивание к переменной типа decimal выполняется (при записи decimal a = 1.1 компилатор ругнется на присвоение double к decimal)
	```cs
	decimal a = (decimal)1.1;
	// или
	decimal a = 1.1M;
	```
- **object** позволяет хранить данные любого типа, но он устарел и к использованию не рекомендуется (при обращении к object надо приводить типы вручную)
- **dynamic** также позволяет хранить значения любого типа, в явном приведении не нуждается, однако IDE не выдает подсказки, т.к. не может определить тип
- **var** определит тип переменной по значению на момент присваивания
- **целевой тип выражения new** (начиная с C# 9) позволяет в сокращенной форме создать экземпляр объект
```cs
	XmlDocument xmlVariable = new(); // сначала тип, потом просто new, не повторяя тип
	// работает и с собственными типами
	class User
	{
		public string login;
	}
	User admin = new();
	admin.login = "administrator";
```
- у всех типов есть значения по умолчанию (напр., для int это 0, для bool - false, для всех ссылочных типов - null)
- значением по умолчанию можно управлять с помощью кл.слова default
- при делении int на 0 падает DivideByZeroException, double же имеет специальные значения PositiveInfinity, NegativeInfinity, NaN и т.д
- массив хранит фиксированное количество элементов, коллекция позволяет динамически добавлять/удалять элементы
- *массив создается как-то контринтуитивно*
```cs
  int[] nums = new int[4]; // т.е. в локальную переменную типа int[] записываем новосозданный массив из 4-х элементов
	int[] nums = new [] { 1, 2, 3, 4 }; // или так
```
- директивы условной компиляции препроцессора: #if, #elif, #else и #endif

## Гл.3 - Управление потоком исполнения, преобразование типов и обработка исключений
- логические операции |, & и условные логические операции ||, && отличаются тем, что первые вычисляют значение обоих операндов, тогда как || и && являются "ленивыми" (правильно - короткозамкнутый аналог логических операций)
- также при работе с целочисленными значениями | и & являются побитовыми (т.е. числа переводятся в двоичную систему и над каждой парой бит выполняется соответствующая операция)
- nameof вовращает короткое имя переменной, sizeof - размер в байтах для простого типа
- операциями также являются:
	- . - доступ к элементу,
	- [] - доступ к индексатору
	- () - операция вызова
	- и множество других

- if поддерживает возможность сопоставления с образцом с помощью операции is
```cs
object ob = "3";
if (ob is int i) // здесь мы объявляем локальную переменную i типа int и проверяем, является ли значение ob типом int
	// ...
else
	// ...
```

- приведение типов может быть:
	- неявное - безопасное, без риска потерять данные, выполняется простым присваиванием (например, приведение int к double)
	- явное - с возможной потерей точности, выполняется через `(тип)переменная`
- также можно выполнить преобразование типов через System.Convert (напр., `ToInt(variable)`, однако при преобразовании есть тонкости, напр., округление вместо отбрасывания дробной части)
- при округлении в C# применяется банковское округление (в отличие от JS, где используется обычное)
- все типы включают в себя `приведение к строке` (`ToString()`), также с помощью типа System.Convert можно выполнить преобразования двоичного объекта в/из base64 (он же - строка безопасных символов) методами ToBase64String и FromBase64String
- приведение к числу или даты выполняется методом `Parse`, который есть у числовых типов и типов даты/времени (для обработки исключений можно использовать метод `TryParse` с out-переменной для записи результата преобразования, сам же метод возвращает true или false)
- в try...catch... для catch можно указать в скобках тип исключения, которое нужно обработать, и фильтр:
```cs
try {...}
catch(DivideByZeroException ex) {} // обработка деления на ноль
catch(DivideByZeroException ex) when variable == "dividing" {} // обработка деления на ноль
catch(FormatException ex) {} // обработка попытки парсинга (напр. буквы в число)
catch(Exception ex) {} // все остальные типы исключений

```
- оборачивая код в checked/unchecked можно включать и выключать выброс ошибки при переполнении (напр., int y = int.MaxValue + 1;)

## Гл.4 - Разработка, отладка и тестирование функций
- полезные окна для отладки (watch, locals, call stack, immediate window) всегда можно добавить в панель отладки через поиск,, если они потерялись
- при отладке для точки останова можно выбрать условие, при котором произойдет останов и действие
- в типе System.Diagnostics есть типы Debug (работает в режиме Debug и Release) и Trace (только в Release), которые могут вести записи в прослушиватели трассировки, писать в файл и т.д.

## Гл.5 - Создание пользовательских типов с помощью ООП
### Концепции ООП (с учетом особенностей C#)
- инкапсуляция - вообще сокрытие, но и комбинация данных объекта и действий над ними + ограничение доступа к внутреннему состоянию объекта
- ассоциация - когда один класс включает в себя другой в качестве одно из полей, при этом:
	- композиция - включаемый класс не может существовать отдельно от включающего его объекта и как правило создается в конструкторе (объект автомобиль включает объект дверь)
	- агрегация - экземпляр включаемого класса создается отдельно и передается во включающий класс (водитель в автомобиль)
- абстракция - описание основной сути класса (кл. словов abstract), при этом от такого класса можно только унаследоваться, но не создать его экземпляр
- наследование и полиморфизм - всё стандартно (наследование, переопределение функционала родителя)


### Пространство имён:
- начиная с .Net 6 и C#10 при объявлении пространства имён можно не оборачивать в него остальной код, а указывать сверху `namespace Space.Name;`

### Члены типа (поля, методы, события):
- поля используются для хранения данных, существуют следующие категории полей:
	- константы - данные там неизвенны, компилатор буквально **копирует такие данные в любой код, который их читает**
	- поля только для чтения - данные могут быть рассчитаны или загружены во время создания экземпляра, но не могу измениться после его создания
	- события - данные ссылаются на один/несколько методов, вызываемых автоматически при возникновении определенной ситуации (читай - хэндлер события, напр., нажатие на кнопку)
- методы - используются для выполнения операторов (**гениальное определение**), есть 4 специализированных категории методов
	- конструкторы - выполняются при использовании кл.слова new для выделения памяти и создания инстанса
	- свойства - используются для получения доступа к данным, использование свойств - предпочтительный способ иинкапсуляции полей (**только если нам не нужно выдать наружу адрес памяти поля**)
	- индексаторы - выполняются, когда нужно получить доступ к данным с помощью [] (?пример?)
	- операции - в книге "выполняются, когда необходимо применить операции типа + и / для операндов вашего типа" (?видимо что-то типа перегрузки операторов?)

### Объекты и наследование
- создание инстанса:
	- Person user = new Person(); // C# 1.0 или более поздние версии
	- var user = new Person(); // C# 3.0 или более поздние версии
	- Person user = new(); // C# 9.0 или более поздние версии
- наследование:
	- все объекты наследуются от System.Object (поэтому, напр., у любого объекта будет метод ToString, который в класс System.Object выводит молное имя пространства имён)
	- класс, от которого происходит наследование, называется базовым или супер-классом
	- класс, который наследуется, называется производным классом, или подклассом
- модификаторы доступа
	- private - содержащий типом (т.е. доступ внутри класса)
	- internal - текущая сборке
	- protected - содержащий тип и его подклассы
	- public - неограниченный доступ
	- internal protected - текущая сборка + все подклассы
	- private protected - содержащий тип + все его подклассы в той же сборке

### Статические члены в классе:
	- обозначаются словом static,
	- все экземпляры имеют общее значение поля, отмеченного static,
	- статическими могут быть поля, методы, конструктоы и другие элементы

### Константные поля в классе:
  - обозначаются словом const,
	- получить значение такого поля можно только по имени класса, но не его экземпляра
	- значение константного поля должно быть известно до компиляции и может быть только строкой, числом или булевым значением

### Readonly-поля, в отличие от константных, могут быть установлены в конструкторе и быть вычислены на этапе компиляции

### Конструкторы и методы
	- методы - это члены типа, выполняющие блок операторов
	- методы - это функции, принадлежащие типу

### кортежи:
	-