# C# и .NET Framework

## Основы программирования

### организация кода, общие вопросы

Статические и экземплярные методы
- Нестатические методы (члены) - методы уровня инстанции (инстанса, экземпляра).
- Методом уровня экземпляра является, например, Contains у экземпляра класса string
- Примером статического метода может быть метод WriteLine у класса Console. Мы используем его, не создавая экземпляр Console (что, в принципе невозможно, тк Console является статическим классом)
- Примером статического метода у класса string может быть string.Concat(), который возвращает экземпляр типа string, но у экземпляра отсутствует. Хороший пример стат свойства - minValue у int


### Типы, приведение, переменные
Приведение типов - cast, может выполняться неявно (например переменную типа byte модно записать в int), явно (byte b = (byte)i, то есть запись значения интовой переменной в байтовую) и только через конвертацию (парсинг), например, распарсив строку в число

NB!
```cs
int i = 5;
double result = i / 2; // даже так в result будет записано 2, чтобы не потерять дробную часть, нужно выполнить поведение внутри операции
double result = (double)i / 2;
```

### Массивы
- в C# длину массива менять нельзя
- типом массивов является Array (напр.. Array someArray = new int[5], в полном же варианте массив создаётся методом Array.CreateInstance()). Если создать массив с помощью данного метода, то обращение по индексу будет невозможно
- запись int[] someArr = new int [5] {1,2,3,4,5} - это синтаксический сахар
- многомерные массивы
```cs
int [,] mArray1 = new int[2,3] { {1,2,3}, {4,5,6}};
int [,] mArray2 = { {1,2,3}, {4,5,6}};
```

При итерировании используются вложенные циклы, а для ограничения вызывается метод GetLength(), выводящий длину текущей строки

Массив может быть сконструирован с настраиваемой индексацией
Array myArray = Array.CreateInstance(typeof(int), new[] {4}, new[] {1});

С помощью методов GetLowerBound и GetUpperBound можно получить начальный и конечный индексы массива

### списки(List)
Тип List под капотом манипулирует массивом. Если, при добавлении элемента, не хватает длины, то массив пересоздается с длиной вдвое больше.
При создании нового объекта типа List используется дженерик для указания типа элементов
var intList = new List<int>() {1,2,3}

### словари(Dictionary)
- используется для создания ассоциативного массива,
- каждый объект словаря является объектом структуры `KeyValuePair<TKey, TValue>`
- как и тип List, он является итерируемым, итерироваться можно по ключам или значениям:
```cs
Dictionary<TKey, TValue>.KeyCollection = someD.Keys;
Dictionary<TKey, TValue>.ValueCollection = someD.Values;
```

Попытка добавить в словарь значение про уже существующему ключу выбросит ошибку.
Есть метод someD.TryAdd, который возвращает boolean, т.о можно обработать попытку в if...else...
Метод someD.TryGetValue так же

Вторым параметром туда можно передать "out string valueString, 0-55,13:18
Абстрактные типы данных стек и очередь в c# имеют в основе массив, равно как list и dictionary

### стек (Stack)
- push, pop и peek (позволяет просмотреть последний добавленный элемент, не извлекая его из стека)
- при итерировании по стеку используется pop, т.о элементы будут удалены
- классический пример работы стека - история операций и их отмена (например, при редактировании текста)

### очередь (Queue)
 - enqueue, dequeue,
 - peek и итерирование аналогично стеку


## ООП в C#

### Общие вопросы
В .Net класс не обязательно моделирует к.-л сущность из предметной области разрабатываемого ПО. Например, класс Program выполняет инфраструктурные задачи, являясь контейнером для метода Main, с которого начинается исполнение программы. В сложных приложениях он выполняет ряд функций по запуску.

В C# в принципе нет функций, только методы. Функция не может быть объявлена вне класса

Сигнатура метода - это имя метода, возвращаемый тип и входящие аргументы с их типами. Методы с разной сигнатурой при совпадающем имени можно перегружать. Перегрузка методов, отличающихся только по типу возвращаемого значения, запрещена в C#

Внутри класса публичные члены имеют доступ к приватным методам и полям.

### Модификаторы члена класса:
- private (по умолчанию для методов и полей класса), не наследуется, по соглашению пишется с маленькой буквы
- public
- internal (по умолчанию для самого класса, классов private не бывает)
- protected

### Свойства в классах

- свойство - это описание для поля геттера и сеттера, например
```cs
private int health = 100;
public int Health {
  get { return health}
  private set { health = value}
}
```
- геттер и сеттер по умолчанию public
- автосвойство используется том случае, если геттер и сеттер только возвращают и устанавливают значение поля без сложной логики и преобразований
```cs
public int Health {get; private set;} = 100;
```


Массив в аргументе метода и кл сл params
В том случае, если метод принимает массив в качестве параметра, то вместо явной передачи массива
public int SomeMethod(int[] numbers)
...
SomeCl.SomeMethod(int [] {1,2,3})
...

Можно использовать ключевое слово params в описании метода. В данном случае массив будет создан имплицитно (неявно). Кл слово params всегда должно идти последним в списке аргументов. Методы с кл словом params нельзя перегружать

public int SomeMethod(params int[] numbers)
...
SomeCl.SomeMethod(1,2,3)
...

### Именованные аргументы

Для улучшения читаемости можно использовать имена перед значением аргументов. Подсказки можно получить в vs через ctrl + .
SomeCl.SomeMethod(order: 1, num: 2, id: 3)

### Методы TryXXX и out-параметры

Это ряд методов, который позволяет обработать исключения, напр TryParse, TryDo

Пример TryParse:

string inputVal = Console.ReadLine();
bool wasParsed = int.TryParse(inputVal, int result)
if (wasParsed)


out-параметры и try-метод

Try-метод можно создать с помощью out-параметра в методе. out-параметр идёт последним, их может быть несколько, у параметра обязательно должно быть значение

Модификатор static
Применим не только к методам, но и свойствам и полям. Статические методы/поля используются, когда объект класса не ориентирован на хранение данных
Ситуация: все поля класса статические. Мы можем создать экземпляр, но не можем вызвать ни одного свойства или метода. В этом случае можно запретить создание экземпляра, сделав статическим сам класс

Статическое поле - общее для всех инстансов класса


Модификатор static:

- модификатор static, методы уровня класса (не инстанции), пример - класс Math, не имеющий состояния (максимум - несколько статических полей с мат.константами). Смысла создания экземпляра такого класса только ради того, чтобы вызывать на нем методы, нет.

- если объявить все методы класса статическими, то экземпляр такого класса создать можно, а вот вызвать ни один метод нельзя (стат.методы недоступны у экземпляра). Странная ситуация. В таком случае и сам класс надо объявить как static.

- статические свойства класса разделяются на все экземпляры класса. Будучи изменено в одном экземпляре, свойство изменится и в остальных. Иными словами статическое поле можно назвать переменой уровня класса. Тогда как обычные поля - переменные уровня экземпляра.


Опциональные параметры
Допустим есть метод, один из параметров которого является флагом, в большинстве случаев стоящим в false. Несмотря на это мы каждый раз обязаны передавать его явно.
Чтобы этого избежать, можно
- перегрузить метод, что достаточно накладно
- использовать значение параметра по умолчанию
SomeMethod(p1, p2, bool p3 = false)

У опционального параметра есть следующие ограничения:
1. Он должен идти последним в списке
2. Значение по умолчанию должно быть compile-time константой (числа, строки, булевы значения) , то есть значениями, вычисляемыми на этапе компиляции и не зависящими от внешних факторов (интересно, дата прокатит???)

Структуры, семантика копирования ссылочных типов и типов-значений

- объект структуры не обязательно создавать через new, можно использовать имя структуры как тип
- при копировании объекта структуры в другую переменную, будет выделен новый участок памяти. Объекты же класса изменяются по ссылке
- но если в поле структуры записан объект класса, то он все равно скопируется по ссылке (что ожидаемо)

Передача значимых и ссылочных типов

1. out- и ref-параметры
- глобально передача по ссылке используется в обоих случаях
- out-параметру внутри метода обязательно должно быть установлено значение
- out-параметры используются как альтернатива return


Null-able структуры:
- у переменной экземпляра ссылочных типов есть специальное состояние, когда ссылка никуда не указывает. При попытке обратиться к полю в таком экземпляре мы получим NullReferenceException. Это давно в случаях:
  - SomeClass cs;
  - SomeClass cs = null;
(!) проверить, что будет при SomeClass cs = new SomeClass();

С value-type переменными данная ошибка не упадёт, тк память выделяется при создании, т.о присвоить структуре (но, естественно, не полю в ней) null нельзя.

Присвоение null структуре, оператор "?"
- это может быть полезно, напр, при считывании из бд
- синтаксис
SomeStruct? ss = null;
if (ss.HasValue) {
  Console.WriteLine(ss.Value.someField);
}

Также можно воспользоваться методом GetValueOrDefault(), который сам проверит nullable-значение и вернёт в его случае значение структуры по умолчанию


Структуры
- структурами являются многие примитивные типы (int, double)
- могут, как и классы, содержать поля и методы
- могут использовать конструкторы, однако экземпляр структуры не обязательно создавать  с его использованием (напр, SomeStrct SmSt;), однако в таком случае все поля обязательно д/б проинициализированы перед обращением к ним
- если же при создании структуры был использован конструктор без параметров, то поля будут проинициализированы значениями по умолчанию соответственно их типам (0 для int и тп)
- конструктор (здесь дать пример) можно определить и самостоятельно, но он обязательно должен инициализировать все поля
- при наличии конструктора инициализировать поля непосредственно в структуре, но вне конструктора, нельзя


Базовый тип Object, память и упаковка
- для получения унифицированной системы типов в cs существует базовый тип, от которого наследуются все остальные типы - тип object
- object позволяет разместить в памяти любой тип (в тч Value Type)
- упаковка / распаковка, проблема с кастингом (приведением), использование object для создания коллекций в прошлом и замена его дженериками (example need)
- проверка упакованного в object типа может быть выполнена с кл сл is (булев флаг и кастинг внутри if), либо с кл сл as (кастинг выполняется автоматически, в случае неудачи в переменную приходит null)
- при упаковке value type в object он перемещается из стека в кучу


Конструкторы
- конструктор можно перегружать
- конструктор по умолчанию не отработает, если определён другой конструктор
- если конструктор вообще не задан, то отработает конструктор по умолчанию, таким образом можно создать экземпляр без начальных параметров
- о конструкторе можно думать как о способе защиты от создания объекта в невалидном состоянии
- this работает ожидаемо
